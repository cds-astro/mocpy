<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mocpy.moc.moc &#8212; MOCPy 0.18.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mocpy.css?v=b2680190" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    
    <script src="../../../_static/documentation_options.js?v=ba2e7b09"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../_static/MOCpy-icon.svg"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">MOC</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">MOCPy 0.18.0 documentation</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for mocpy.moc.moc</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">log2</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">urllib.error</span><span class="w"> </span><span class="kn">import</span> <span class="n">HTTPError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">urllib.parse</span><span class="w"> </span><span class="kn">import</span> <span class="n">urlencode</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">wcs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.coordinates</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">ICRS</span><span class="p">,</span>
    <span class="n">Angle</span><span class="p">,</span>
    <span class="n">BaseCoordinateFrame</span><span class="p">,</span>
    <span class="n">Galactic</span><span class="p">,</span>
    <span class="n">Latitude</span><span class="p">,</span>
    <span class="n">Longitude</span><span class="p">,</span>
    <span class="n">SkyCoord</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.table</span><span class="w"> </span><span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.utils.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">download_file</span>

<span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">suppress</span><span class="p">(</span><span class="ne">ImportError</span><span class="p">):</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">regions</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy_healpix</span><span class="w"> </span><span class="kn">import</span> <span class="n">HEALPix</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..</span><span class="w"> </span><span class="kn">import</span> <span class="n">mocpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..abstract_moc</span><span class="w"> </span><span class="kn">import</span> <span class="n">AbstractMOC</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.boundaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Boundaries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.plot</span><span class="w"> </span><span class="kn">import</span> <span class="n">border</span><span class="p">,</span> <span class="n">fill</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.plot.wcs</span><span class="w"> </span><span class="kn">import</span> <span class="n">WCS</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Matthieu Baumann, Thomas Boch, Manon Marchand, François-Xavier Pineau&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;CDS, Centre de Données astronomiques de Strasbourg&quot;</span>

<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;BSD 3-Clause License&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;matthieu.baumann@astro.unistra.fr, thomas.boch@astro.unistra.fr, manon.marchand@astro.unistra.fr, francois-xavier.pineau@astro.unistra.fr&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">validate_lonlat</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate the longitude and latitudes entries of methods of the MOC class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function : &lt;class &#39;function&#39;&gt;</span>
<span class="sd">        must have the signature function(self, lon, lat, **kwargs)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        applies desired transformations for the `lon` and `lat` arguments and calls</span>
<span class="sd">        `function` with these modified arguments</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `lon` and `lat` have inconsistent shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_lonlat_wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># be sure that lon and lat are of the same shape</span>
        <span class="k">if</span> <span class="n">lon</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;lon&#39; and &#39;lat&#39; should have the same shape but are of shapes </span><span class="si">{</span><span class="n">lon</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># lon and lat should be casted to arrays</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="c1"># convert into astropy objects</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">lon</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">)</span> <span class="k">else</span> <span class="n">Longitude</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">Latitude</span><span class="p">)</span> <span class="k">else</span> <span class="n">Latitude</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="c1"># convert to degrees</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">lon</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_validate_lonlat_wrap</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_mask_unsigned_before_casting</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a mask for an array of integers if there are negative values.</span>

<span class="sd">    This is useful before casting indices into unsigned integers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices : `numpy.ndarray` or Iterable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;The list of indices contain negative values. They are filtered &quot;</span>
        <span class="s2">&quot;out to generate the MOC&quot;</span><span class="p">,</span>
        <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_mask_and_values_multiordermap</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract uniq and values with their masks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    multiordermap : astropy.table.Table</span>
<span class="sd">        The table should have a column named ``UNIQ`` that corresponds to HEALPix</span>
<span class="sd">        cells in the uniq notation.</span>
<span class="sd">    column : str</span>
<span class="sd">        The name of the column to retrieve. It should contain float-compatible values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (uniq, uniq_mask, values, values_mask)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">uniq</span> <span class="o">=</span> <span class="n">multiordermap</span><span class="p">[</span><span class="s2">&quot;UNIQ&quot;</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">multiordermap</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">uniq_mask</span> <span class="o">=</span> <span class="n">uniq</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">uniq_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">values_mask</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">values_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uniq</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uniq_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span>
    <span class="p">)</span>


<div class="viewcode-block" id="MOC">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MOC</span><span class="p">(</span><span class="n">AbstractMOC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multi-order spatial coverage class.</span>

<span class="sd">    A MOC describes the coverage of an arbitrary region on the unit sphere.</span>
<span class="sd">    MOCs are usually used for describing the global coverage of catalog/image surveys such as GALEX or SDSS.</span>
<span class="sd">    A MOC corresponds to a list of `HEALPix &lt;https://healpix.sourceforge.io/&gt;`__ cells at different depths.</span>
<span class="sd">    This class gives you the possibility to:</span>

<span class="sd">    1. Define `~mocpy.MOC` objects:</span>

<span class="sd">    - From a FITS file that stores HEALPix cells (see `load(path, &#39;fits&#39;)`).</span>
<span class="sd">    - Directly from a list of HEALPix cells expressed either as a numpy structural array (see `from_healpix_cells`) or a simple</span>
<span class="sd">      python dictionary (see `from_json`).</span>
<span class="sd">    - From a list of sky coordinates (see `from_skycoords`, `from_lonlat`).</span>
<span class="sd">    - From a convex/concave polygon (see `from_polygon`).</span>
<span class="sd">    - From a cone (will be implemented in a next version).</span>

<span class="sd">    2. Perform fast logical operations between `~mocpy.MOC` objects:</span>

<span class="sd">    - The `intersection`</span>
<span class="sd">    - The `union`</span>
<span class="sd">    - The `difference`</span>
<span class="sd">    - The `complement`</span>


<span class="sd">    3. Plot the `~mocpy.MOC` objects:</span>

<span class="sd">    - Draw the MOC with its HEALPix cells (see `fill`)</span>
<span class="sd">    - Draw the perimeter of a MOC (see `border`)</span>

<span class="sd">    4. Get the sky coordinates defining the border(s) of `~mocpy.MOC` objects (see `get_boundaries`).</span>

<span class="sd">    5. Serialize `~mocpy.MOC` objects to `astropy.io.fits.HDUList` or JSON dictionary and save it to a file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Maximum order (or depth) of a MOC</span>
    <span class="c1"># (do not remove since it may be used externally).</span>
    <span class="n">MAX_ORDER</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is a Spatial Coverage (S-MOC).</span>

<span class="sd">        Args:</span>
<span class="sd">            create_key: Object ensure __init__ is called by super-class/class-methods only</span>
<span class="sd">            store_index: index of the S-MOC in the rust-side storage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_index</span> <span class="o">=</span> <span class="n">store_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Depth/order of the S-MOC.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">get_smoc_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">)</span>

<div class="viewcode-block" id="MOC.n_cells">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.n_cells">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_cells</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of cells for a given depth.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        depth : int</span>
<span class="sd">            The depth. It is comprised between 0 and `~mocpy.moc.MOC.MAX_ORDER`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of cells at the given order</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; MOC.n_cells(0)</span>
<span class="sd">        12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="bp">cls</span><span class="o">.</span><span class="n">MAX_ORDER</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The depth should be comprised between 0 and </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">MAX_ORDER</span><span class="si">}</span><span class="s2">, but </span><span class="si">{</span><span class="n">depth</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="s2">&quot; was provided.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">n_cells_smoc</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.split_count">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.split_count">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_indirect_neighbours</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of disjoint MOCs the given MOC contains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_indirect_neighbours : bool</span>
<span class="sd">            if `false`, only consider  cells having a common edge as been part of a same MOC</span>
<span class="sd">            if `true`, also consider cells having a common vertex as been part of the same MOC</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">split_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">include_indirect_neighbours</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.split">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.split">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_indirect_neighbours</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the disjoint MOCs this MOC contains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_indirect_neighbours : bool</span>
<span class="sd">            if `false`, only consider  cells having a common edge as been part of a same MOC</span>
<span class="sd">            if `true`, also consider cells having a common vertex as been part of the same MOC</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Use `~mocpy.moc.MOC.split_count` first to ensure the number is not too high</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">include_indirect_neighbours</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">MOC</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="MOC.degrade_to_order">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.degrade_to_order">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">degrade_to_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Degrade the MOC instance to a new, less precise, MOC.</span>

<span class="sd">        The maximum depth (i.e. the depth of the smallest HEALPix cells that can be found in the MOC) of the</span>
<span class="sd">        degraded MOC is set to ``new_order``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_order : int</span>
<span class="sd">            Maximum depth of the output degraded MOC.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The degraded MOC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_order</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The new order is more precise than the current order, nothing done.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">degrade</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">new_order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MOC</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.refine_to_order">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.refine_to_order">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">refine_to_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Refine the order of the MOC instance to a more precise order.</span>

<span class="sd">        This is an in-place operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_order : int</span>
<span class="sd">            New maximum order for this MOC.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `mocpy.MOC`</span>
<span class="sd">            Returns itself, after in-place modification.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_str(&quot;3/10&quot;)</span>
<span class="sd">        &gt;&gt;&gt; moc</span>
<span class="sd">        3/10</span>
<span class="sd">        &gt;&gt;&gt; moc.refine_to_order(5)</span>
<span class="sd">        3/10</span>
<span class="sd">        5/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_order</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;&#39;new_order&#39; is less precise than the current max order. Nothing done.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">mocpy</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">new_order</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MOC.to_order">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.to_order">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new S-MOC with the new order.</span>

<span class="sd">        This is a convenience method for a quick change of order.</span>
<span class="sd">        Using &#39;degrade_to_order&#39; and &#39;refine_to_order&#39; depending on the situation is</span>
<span class="sd">        more efficient and avoids copying the MOC when it is not needed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_order : int</span>
<span class="sd">            The new order for the S-MOC. Can be either more or less precise than the</span>
<span class="sd">            current max_order of the S-MOC</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            A new S-MOC instance with the given max order.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_string(&quot;15/0-100&quot;)</span>
<span class="sd">        &gt;&gt;&gt; moc.to_order(15) # creates a copy</span>
<span class="sd">        12/0</span>
<span class="sd">        13/4-5</span>
<span class="sd">        14/24</span>
<span class="sd">        15/100</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        degrade_to_order : to create a new less precise MOC</span>
<span class="sd">        refine_to_order : to change the order to a more precise one in place (no copy)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_order</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">:</span>
            <span class="n">moc_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">moc_copy</span><span class="o">.</span><span class="n">refine_to_order</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_order</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrade_to_order</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.contains_skycoords">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.contains_skycoords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains_skycoords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skycoords</span><span class="p">,</span> <span class="n">keep_inside</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean mask array of the positions lying inside (or outside) the MOC instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skycoords : `astropy.coordinates.SkyCoord`</span>
<span class="sd">            The sky coordinates that will be tested.</span>
<span class="sd">        keep_inside : bool, optional</span>
<span class="sd">            True by default. If so the mask describes coordinates lying inside the MOC. If ``keep_inside``</span>
<span class="sd">            is false, contains will return the mask of the coordinates lying outside the MOC.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~np.ndarray`</span>
<span class="sd">            A mask boolean array</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        contains_lonlat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_lonlat</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">skycoords</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
            <span class="n">lat</span><span class="o">=</span><span class="n">skycoords</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
            <span class="n">keep_inside</span><span class="o">=</span><span class="n">keep_inside</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.contains">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.contains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">keep_inside</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test wether a MOC contains --or not-- the given points. Returns a boolean mask array.</span>

<span class="sd">        .. deprecated:: 0.11.1</span>
<span class="sd">          `contains` is replaced by</span>
<span class="sd">          `contains_lonlat` for naming consistency.</span>
<span class="sd">          Please consider switching.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            Right ascension array in deg</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            Declination array in deg</span>
<span class="sd">        keep_inside : bool, optional</span>
<span class="sd">            True by default. If so the mask describes coordinates lying inside the MOC. If ``keep_inside``</span>
<span class="sd">            is false, contains will return the mask of the coordinates lying outside the MOC.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : `~np.ndarray`</span>
<span class="sd">            A mask boolean array</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        contains_skycoords</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This method is deprecated and has been replaced by contains_lonlat&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_lonlat</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">keep_inside</span><span class="o">=</span><span class="n">keep_inside</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.contains_lonlat">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.contains_lonlat">[docs]</a>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains_lonlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">keep_inside</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test wether a MOC contains (or not) the given points. Returns a boolean mask array.</span>

<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            Right ascension array in deg</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            Declination array in deg</span>
<span class="sd">        keep_inside : bool, optional</span>
<span class="sd">            True by default. If so the mask describes coordinates lying inside the MOC.</span>
<span class="sd">            If ``keep_inside`` is false, contains will return the mask of the coordinates</span>
<span class="sd">            lying outside the MOC.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : If `lon` and `lat` have mismatched shapes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~np.ndarray`</span>
<span class="sd">            A mask boolean array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import Angle</span>
<span class="sd">        &gt;&gt;&gt; # create lists of coordinates</span>
<span class="sd">        &gt;&gt;&gt; lon = Angle([1, 2, 3, -2, -40, -5], unit=&quot;deg&quot;)</span>
<span class="sd">        &gt;&gt;&gt; lat = Angle([20, 25, 10, -60, 80, 0], unit=&quot;deg&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # create a polygonal moc from these</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_polygon(lon=lon, lat=lat, max_depth=12)</span>
<span class="sd">        &gt;&gt;&gt; moc.contains_lonlat(lon=lon, lat=lat) # returns all true</span>
<span class="sd">        array([ True,  True,  True, True,  True,  True])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        contains_skycoords</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">filter_pos</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span>
            <span class="n">lon</span><span class="p">,</span>
            <span class="n">lat</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_inside</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># noqa: RET505</span>
            <span class="k">return</span> <span class="o">~</span><span class="n">mask</span></div>


    <span class="c1"># TODO: implement: def contains_including_surrounding(self, lon, lat, distance)</span>

<div class="viewcode-block" id="MOC.fill">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.fill">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_mpl_pathpatch</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the MOC on a matplotlib axis.</span>

<span class="sd">        This performs the projection of the cells from the world coordinate system to the</span>
<span class="sd">        pixel image coordinate system. You can provide style keyword arguments as in</span>
<span class="sd">        `matplotlib.patches.PathPatch`</span>
<span class="sd">        (see the `list of valid keywords</span>
<span class="sd">        &lt;https://matplotlib.org/api/_as_gen/matplotlib.patches.PathPatch.html#matplotlib.patches.PathPatch&gt;`__).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : `matplotlib.axes.Axes`</span>
<span class="sd">            Matplotlib axis.</span>
<span class="sd">        wcs : `astropy.wcs.WCS`</span>
<span class="sd">            WCS defining the World system &lt;-&gt; Image system projection.</span>
<span class="sd">        optimize : bool, optional</span>
<span class="sd">            If this is set to True, the MOC will be degraded so that no HEALPix will be</span>
<span class="sd">            smaller than one pixel as defined by the WCS. It can be useful to deactivate this</span>
<span class="sd">            optimization for svg outputs or if you take an insert of a WCS. Default is True.</span>
<span class="sd">        kw_mpl_pathpatch</span>
<span class="sd">            Plotting arguments for `matplotlib.patches.PathPatch`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; # Create a MOC</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_ring(external_radius=2*u.deg,</span>
<span class="sd">        ...                     internal_radius=1*u.deg,</span>
<span class="sd">        ...                     lat=0*u.rad, lon=0*u.rad,</span>
<span class="sd">        ...                     max_depth=13,</span>
<span class="sd">        ...                    )</span>
<span class="sd">        &gt;&gt;&gt; # Plot the MOC using matplotlib</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 10))</span>
<span class="sd">        &gt;&gt;&gt; wcs = moc.wcs(fig)</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(projection=wcs)</span>
<span class="sd">        &gt;&gt;&gt; moc.fill(ax, wcs, color=&#39;blue&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fill</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_mpl_pathpatch</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.border">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.border">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">border</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_mpl_pathpatch</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the MOC border.s on a matplotlib axis.</span>

<span class="sd">        This performs the projection of the sky coordinates defining the perimeter of the MOC to the pixel image coordinate system.</span>
<span class="sd">        You are able to specify various styling kwargs for `matplotlib.patches.PathPatch`</span>
<span class="sd">        (see the `list of valid keywords &lt;https://matplotlib.org/api/_as_gen/matplotlib.patches.PathPatch.html#matplotlib.patches.PathPatch&gt;`__).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : `matplotlib.axes.Axes`</span>
<span class="sd">            Matplotlib axis.</span>
<span class="sd">        wcs : `astropy.wcs.WCS`</span>
<span class="sd">            WCS defining the World system &lt;-&gt; Image system projection.</span>
<span class="sd">        kw_mpl_pathpatch</span>
<span class="sd">            Plotting arguments for `matplotlib.patches.PathPatch`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import Latitude, Longitude</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; # Create a MOC</span>
<span class="sd">        &gt;&gt;&gt; lon = Longitude([5, -5, -5, 5], u.deg)</span>
<span class="sd">        &gt;&gt;&gt; lat = Latitude([5, 5, -5, -5], u.deg)</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_polygon(lon, lat)</span>
<span class="sd">        &gt;&gt;&gt; # Plot the MOC using matplotlib</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 10))</span>
<span class="sd">        &gt;&gt;&gt; wcs = moc.wcs(fig)</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(projection=wcs)</span>
<span class="sd">        &gt;&gt;&gt; moc.border(ax, wcs, color=&#39;blue&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">border</span><span class="o">.</span><span class="n">border</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_mpl_pathpatch</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.get_boundaries">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.get_boundaries">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sky coordinates defining the border(s) of the MOC.</span>

<span class="sd">        The border(s) are expressed as a list of SkyCoord.</span>
<span class="sd">        Each SkyCoord refers to the coordinates of one border of the MOC (i.e.</span>
<span class="sd">        either a border of a connected MOC part or a border of a hole</span>
<span class="sd">        located in a connected MOC part).</span>
<span class="sd">        This function is currently not stable: encoding a vertex of a</span>
<span class="sd">        HEALPix cell (N, E, S, W) should not depend on the position of the</span>
<span class="sd">        vertex but rather on the uniq value (+ 2 bits to encode the direction</span>
<span class="sd">        of the vertex).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : int</span>
<span class="sd">            The depth of the MOC before computing its boundaries.</span>
<span class="sd">            A shallow depth leads to a faster computation.</span>
<span class="sd">            By default the maximum depth of the MOC is taken.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        DeprecationWarning</span>
<span class="sd">            This method is not stable and not tested! A future more stable algorithm will be implemented!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        [`~astropy.coordinates.SkyCoord`]</span>
<span class="sd">            A list of `~astropy.coordinates.SkyCoord` each describing one border.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This method is not stable. A future more stable algorithm will be implemented!&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Boundaries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_fits_image">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_fits_image">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_fits_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">hdu</span><span class="p">,</span> <span class="n">max_norder</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">approximate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a `~mocpy.MOC` from an image stored as a FITS file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hdu : HDU object</span>
<span class="sd">            HDU containing the data of the image</span>
<span class="sd">        max_norder : int</span>
<span class="sd">            The moc resolution.</span>
<span class="sd">        mask : `numpy.ndarray`, optional</span>
<span class="sd">            A boolean array of the same shape than the image where True valued pixels are part of</span>
<span class="sd">            the final MOC and False valued pixels are not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When giving a mask, the MOC computed will only take into account the center</span>
<span class="sd">        of the image pixels and not the whole pixel borders.</span>
<span class="sd">        This leads to an approximate resulting MOC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Only take the first HDU</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span>
        <span class="n">max_norder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_norder</span><span class="p">)</span>

        <span class="c1"># Compute a WCS from the header of the image</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">calc_footprint</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approximate</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">sky_corners</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">corners</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corners</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">MOC</span><span class="o">.</span><span class="n">from_polygon_skycoord</span><span class="p">(</span><span class="n">sky_corners</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">max_norder</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Corners of at least one of the images cannot be &quot;</span>
                <span class="s2">&quot;calculated with its WCS, the &#39;approximate&#39; method &quot;</span>
                <span class="s2">&quot;cannot be used for this image.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># A mask is computed discarding nan floating values</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># If the BLANK keyword is set to a value then we mask those</span>
            <span class="c1"># pixels too</span>
            <span class="k">if</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;BLANK&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">discard_val</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;BLANK&quot;</span><span class="p">]</span>

                <span class="c1"># We keep the finite values and those who are not equal to the BLANK field</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="n">discard_val</span><span class="p">)</span>

        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">world</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">wcs_pix2world</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Remove coord containing inf/nan values</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">world</span><span class="p">)</span>

        <span class="c1"># It is a good coordinates whether both its coordinate are good</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">good</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">good</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">world</span> <span class="o">=</span> <span class="n">world</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>

        <span class="c1"># Get the frame from the wcs</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">wcs_to_celestial_frame</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">skycrd</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;deg&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">)</span>

        <span class="c1"># Compute the deepest HEALPix order containing at least one 1 pixel of the image</span>
        <span class="c1"># We want the order so that area_hpx_cell &gt;= area_img_pixel</span>
        <span class="c1"># &lt;=&gt; 4pi / (12 * 2^(2*order)) in [steradians] &gt;= area_img_pixel in [steradians]</span>
        <span class="n">healpix_order_computed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">sky_corners</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">corners</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corners</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>

            <span class="p">[</span><span class="n">w_img_px</span><span class="p">,</span> <span class="n">h_img_px</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># take angular distances between the corners in x and y image space directions</span>
            <span class="n">px_ang_size_x</span> <span class="o">=</span> <span class="n">sky_corners</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">separation</span><span class="p">(</span><span class="n">sky_corners</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">w_img_px</span>
            <span class="n">px_ang_size_y</span> <span class="o">=</span> <span class="n">sky_corners</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">separation</span><span class="p">(</span><span class="n">sky_corners</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">h_img_px</span>

            <span class="n">px_sky_area</span> <span class="o">=</span> <span class="n">px_ang_size_x</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">px_ang_size_y</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span>
                <span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># in steradians</span>

            <span class="c1"># Division by 0 case</span>
            <span class="k">if</span> <span class="n">px_sky_area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">healpix_order_computed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">depth_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">px_sky_area</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">max_norder</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_norder</span><span class="p">,</span> <span class="n">depth_px</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">healpix_order_computed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">healpix_order_computed</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;MOC precision HEALPix order could not be determined because sky coordinates &quot;</span>
                <span class="s2">&quot;from the corners of the image has not have been correctly retrieved. &quot;</span>
                <span class="s2">&quot;Therefore MOC precision will be set to max_norder&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">moc</span> <span class="o">=</span> <span class="n">MOC</span><span class="o">.</span><span class="n">from_lonlat</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">skycrd</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
            <span class="n">lat</span><span class="o">=</span><span class="n">skycrd</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
            <span class="n">max_norder</span><span class="o">=</span><span class="n">max_norder</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">moc</span>  <span class="c1"># noqa: RET504</span></div>


<div class="viewcode-block" id="MOC.from_fits_images">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_fits_images">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_fits_images</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_l</span><span class="p">,</span> <span class="n">max_norder</span><span class="p">,</span> <span class="n">hdu_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">approximate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a MOC from a set of FITS file images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_l : [str]</span>
<span class="sd">            A list of path where the fits images are located.</span>
<span class="sd">        max_norder : int</span>
<span class="sd">            The MOC resolution.</span>
<span class="sd">        hdu_index : int, optional</span>
<span class="sd">            Index of the the HDUs containing the image in each FITS file (default = 0)</span>
<span class="sd">            If set to -1, all the HUD will be taken in account, and only the ones</span>
<span class="sd">            corresponding to images will be kept.</span>
<span class="sd">        approximate : bool, optional</span>
<span class="sd">            A faster but less precise way to build the MOC out of the images. This does</span>
<span class="sd">            not mask the boolean values, and will approximate each image as a polygon</span>
<span class="sd">            defined by the footprint deduced from the WCS. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moc : `~mocpy.MOC`</span>
<span class="sd">            The union of all the MOCs created from the paths found in ``path_l``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_l</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">path_l</span> <span class="o">=</span> <span class="p">[</span><span class="n">path_l</span><span class="p">]</span>

        <span class="n">mocs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">hdu_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">path_l</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdul</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="n">hdul</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="nb">isinstance</span><span class="p">(</span>
                                <span class="n">hdu</span><span class="p">,</span> <span class="p">(</span><span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">,</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">,</span> <span class="n">fits</span><span class="o">.</span><span class="n">CompImageHDU</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="ow">and</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span>
                            <span class="ow">and</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;NAXIS&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="p">):</span>
                            <span class="n">mocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="c1"># noqa: PERF401</span>
                                <span class="n">MOC</span><span class="o">.</span><span class="n">from_fits_image</span><span class="p">(</span>
                                    <span class="n">hdu</span><span class="p">,</span>
                                    <span class="n">max_norder</span><span class="p">,</span>
                                    <span class="n">approximate</span><span class="o">=</span><span class="n">approximate</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">path_l</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdul</span><span class="p">:</span>
                    <span class="n">mocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">MOC</span><span class="o">.</span><span class="n">from_fits_image</span><span class="p">(</span>
                            <span class="n">hdul</span><span class="p">[</span><span class="n">hdu_index</span><span class="p">],</span> <span class="n">max_norder</span><span class="p">,</span> <span class="n">approximate</span><span class="o">=</span><span class="n">approximate</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mocs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;No image HDU found, returning an empty MOC.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">MOC</span><span class="o">.</span><span class="n">new_empty</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="n">max_norder</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mocs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">mocs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># this is the fastest way to do multi union</span></div>


<div class="viewcode-block" id="MOC.from_vizier_table">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_vizier_table">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_vizier_table</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">table_id</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nside</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `~mocpy.MOC` object from a VizieR table or catalog.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table_id : str</span>
<span class="sd">            Table or catalog identifier</span>
<span class="sd">        max_depth : int, optional</span>
<span class="sd">            The depth at which the MOC should be retrieved. The default (which is also the</span>
<span class="sd">            most precise available on the server) is order 11 for tables and order 10 for</span>
<span class="sd">            catalogs.</span>
<span class="sd">        nside : int, optional and deprecated</span>
<span class="sd">            It is deprecated in favor of max_depth since version 0.6.0</span>
<span class="sd">            You can switch to maw_depth by calculating max_depht = log2(nside).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_vizier_table(&quot;J/A+A/675/A154/tableb1&quot;) # download the MOC</span>
<span class="sd">        &gt;&gt;&gt; round(moc.sky_fraction, 6) # let&#39;s print the sky fraction of the MOC</span>
<span class="sd">        4e-06</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        VizieR is organized by catalogs that correspond to published articles or to data</span>
<span class="sd">        releases. These catalogs contain one or more tables.</span>

<span class="sd">        Here are two webpages where you can read the</span>
<span class="sd">        `list of catalogs &lt;https://cdsarc.cds.unistra.fr/viz-bin/moc/?format=html&gt;`_</span>
<span class="sd">        and the `list of tables &lt;https://cdsarc.cds.unistra.fr/viz-bin/moc/?format=html&amp;list=tables&gt;`_</span>
<span class="sd">        currently available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nside</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;&#39;nside&#39; is deprecated in favor of &#39;max_depth&#39;. We use the nside&quot;</span>
                <span class="s2">&quot;value for this request. You can switch to max_depth with &quot;</span>
                <span class="s2">&quot;max_depth = log2(nside).&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">nside_possible_values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nside</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nside_possible_values</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Bad value for nside. Must be in </span><span class="si">{</span><span class="n">nside_possible_values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">nside</span><span class="p">)</span>

        <span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;https://cdsarc.cds.unistra.fr/viz-bin/moc/</span><span class="si">{</span><span class="n">table_id</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;?order=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">max_depth</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">moc</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">HTTPError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">code</span> <span class="o">==</span> <span class="mi">400</span><span class="p">:</span>
                <span class="c1"># we provide a clearer error for code 400 bad request</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No catalog/table was found for &#39;</span><span class="si">{</span><span class="n">table_id</span><span class="si">}</span><span class="s2">&#39;. You can see the list of &quot;</span>
                    <span class="s2">&quot;catalogs at https://cdsarc.cds.unistra.fr/viz-bin/moc/?format=html &quot;</span>
                    <span class="s2">&quot;and the list of tables at &quot;</span>
                    <span class="s2">&quot;https://cdsarc.cds.unistra.fr/viz-bin/moc/?format=html&amp;list=tables .&quot;</span><span class="p">,</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>
            <span class="k">raise</span> <span class="n">error</span>
        <span class="k">return</span> <span class="n">moc</span></div>


<div class="viewcode-block" id="MOC.from_ivorn">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_ivorn">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_ivorn</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ivorn</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">nside</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `~mocpy.MOC` object from a given IVORN.</span>

<span class="sd">        IVORNs are standardized unique identifiers used within the virtual observatory.</span>
<span class="sd">        This method queries the MOCServer, a CDS service that can also be found through</span>
<span class="sd">        its webpages https://alasky.cds.unistra.fr/MocServer/query</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ivorn : str</span>
<span class="sd">            A valid Virtual Observatory IVORN</span>
<span class="sd">        max_depth : int, defaults to 8</span>
<span class="sd">            The depth at which the MOC should be retrieved.</span>
<span class="sd">        nside : int, optional and deprecated</span>
<span class="sd">            It is deprecated in favor of max_depth since version 0.6.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; MOC.from_ivorn(&quot;ivo://CDS/J/A+AS/133/387/table5&quot;)</span>
<span class="sd">        7/96462 96481 96484-96486</span>
<span class="sd">        8/385839 385852 385854-385855 385933 385948-385950 385969 385984 385986</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a rudimentary way to retrieve MOCs from the MOCServer. For a more</span>
<span class="sd">        complete implementation, see the MOCServer module in the astroquery library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nside</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;&#39;nside&#39; is deprecated in favor of &#39;max_depth&#39;. We use the nside&quot;</span>
                <span class="s2">&quot;value for this request. You can switch to max_depth with &quot;</span>
                <span class="s2">&quot;max_depth = log2(nside).&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">nside_possible_values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nside</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nside_possible_values</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Bad value for nside. Must be in </span><span class="si">{</span><span class="n">nside_possible_values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">nside</span><span class="p">)</span>

        <span class="n">moc</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_url</span><span class="p">(</span>
            <span class="s2">&quot;http://alasky.unistra.fr/MocServer/query?&quot;</span>
            <span class="o">+</span> <span class="n">urlencode</span><span class="p">({</span><span class="s2">&quot;ivorn&quot;</span><span class="p">:</span> <span class="n">ivorn</span><span class="p">,</span> <span class="s2">&quot;get&quot;</span><span class="p">:</span> <span class="s2">&quot;moc&quot;</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_depth</span><span class="p">)}),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">moc</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;This MOC is empty. Possible causes are that this IVORN has no &quot;</span>
                <span class="s2">&quot;positions or this is not a valid IVORN.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">moc</span></div>


<div class="viewcode-block" id="MOC.from_url">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_url">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_url</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a `~mocpy.MOC` object from a given url.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        url : str</span>
<span class="sd">            The url of a FITS file storing a MOC.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: as is, this is a duplicate of abstract class `from_fits` called with an url</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">download_file</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;fits&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_skycoords">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_skycoords">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_skycoords</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">skycoords</span><span class="p">,</span> <span class="n">max_norder</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from an `astropy.coordinates.SkyCoord`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skycoords : `astropy.coordinates.SkyCoord`</span>
<span class="sd">            The sky coordinates that will belong to the MOC.</span>
<span class="sd">        max_norder : int</span>
<span class="sd">            The depth of the smallest HEALPix cells contained in the MOC.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_lonlat</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">skycoords</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
            <span class="n">lat</span><span class="o">=</span><span class="n">skycoords</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
            <span class="n">max_norder</span><span class="o">=</span><span class="n">max_norder</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_lonlat">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_lonlat">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_lonlat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">max_norder</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from astropy lon, lat `astropy.units.Quantity`.</span>

<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The longitudes of the sky coordinates belonging to the MOC.</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The latitudes of the sky coordinates belonging to the MOC.</span>
<span class="sd">        max_norder : int</span>
<span class="sd">            The depth of the smallest HEALPix cells contained in the MOC.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_lonlat</span><span class="p">(</span>
            <span class="n">max_norder</span><span class="p">,</span>
            <span class="n">lon</span><span class="p">,</span>
            <span class="n">lat</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_multiordermap_fits_file">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_multiordermap_fits_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_multiordermap_fits_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">path</span><span class="p">,</span>
        <span class="n">cumul_from</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">cumul_to</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">asc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">no_split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">reverse_decent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a mutli-order map FITS file.</span>

<span class="sd">        HEALPix cells are first sorted by their values.</span>
<span class="sd">        The MOC contains the cells from which the cumulative value is between</span>
<span class="sd">        ``cumul_from`` and ``cumul_to``.</span>
<span class="sd">        Cells being on the fence are recursively splitted and added</span>
<span class="sd">        until the depth of the cells is equal to ``max_norder``.</span>

<span class="sd">        For compatibility with Aladin, use ``no_split=False`` and ``reverse_decent=True``</span>

<span class="sd">        Remark: using ``no_split=False``, the way the cells overlapping with the low and high thresholds are split</span>
<span class="sd">        is somewhat arbitrary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str or pathlib.Path</span>
<span class="sd">            The path to the file to save the MOC in.</span>
<span class="sd">        cumul_from : float</span>
<span class="sd">            Cumulative value from which cells will be added to the MOC</span>
<span class="sd">        cumul_to : float</span>
<span class="sd">            Cumulative value to which cells will be added to the MOC</span>
<span class="sd">        asc: boolean</span>
<span class="sd">            the cumulative value is computed from lower to highest densities instead of from highest to lowest</span>
<span class="sd">        strict: boolean</span>
<span class="sd">            (sub-)cells overlapping the ``cumul_from`` or ``cumul_to`` values are not added</span>
<span class="sd">        no_split: boolean</span>
<span class="sd">            cells overlapping the ``cumul_from`` or ``cumul_to`` values are not recursively split</span>
<span class="sd">        reverse_decent: boolean</span>
<span class="sd">            perform the recursive decent from the highest cell number to the lowest (to be compatible with Aladin)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">spatial_moc_from_multiordermap_fits_file</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cumul_from</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cumul_to</span><span class="p">),</span>
            <span class="n">asc</span><span class="p">,</span>
            <span class="n">strict</span><span class="p">,</span>
            <span class="n">no_split</span><span class="p">,</span>
            <span class="n">reverse_decent</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.probabilities_in_multiordermap">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.probabilities_in_multiordermap">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">probabilities_in_multiordermap</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mocs</span><span class="p">,</span> <span class="n">multiordermap</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the probabilities in the intersection between the multiordermap and the MOCs.</span>

<span class="sd">        Multi-MOC version of `probability_in_multiordermap`. This is parallelized.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mocs : list[mocpy.MOC]</span>
<span class="sd">            A list of `mocpy.MOC`.</span>
<span class="sd">        multiordermap : astropy.table.Table, or astropy.table.QTable</span>
<span class="sd">            Should have a column ``UNIQ`` that</span>
<span class="sd">            corresponds to HEALPix cells and a ``PROBDENSITY`` column.</span>
<span class="sd">        n_threads : int</span>
<span class="sd">            Number of threads to be used (all available threads by default)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[float]</span>
<span class="sd">            A list containing the probability for each MOC</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In wasm compilations (ex for pyodide), this won&#39;t raise an error, but will be</span>
<span class="sd">        single-threaded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;An argument of type &#39;astropy.table.Table&#39;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; is expected. Got &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">moc</span><span class="o">.</span><span class="n">store_index</span> <span class="k">for</span> <span class="n">moc</span> <span class="ow">in</span> <span class="n">mocs</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">_store_index_dtype</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">multi_multiorder_probdens_map_sum_in_smoc</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span>
            <span class="o">*</span><span class="n">_extract_mask_and_values_multiordermap</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="s2">&quot;PROBDENSITY&quot;</span><span class="p">),</span>
            <span class="n">n_threads</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.probability_in_multiordermap">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.probability_in_multiordermap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">probability_in_multiordermap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiordermap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the probability in the intersection between the multiordermap and the MOC.</span>

<span class="sd">        ``PROBDENSITY`` values are multiplied by the area of their associated HEALPix</span>
<span class="sd">        cell before summing them. For cells that are not complete, the ratio of the area</span>
<span class="sd">        is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiordermap : str, pathlib.Path, astropy.table.Table, or astropy.table.QTable</span>
<span class="sd">            If ``multiordermap`` is given as a string or `~pathlib.Path`, the probability</span>
<span class="sd">            will be read from the column ``PROBDENSITY`` of the FITS file.</span>
<span class="sd">            If it is an `~astropy.table.Table`, then it should have a column ``UNIQ`` that</span>
<span class="sd">            corresponds to HEALPix cells and a ``PROBDENSITY`` column.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The probability in the intersection between the MOC and the Multi-Order-Map</span>
<span class="sd">            coverages.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from astropy.table import Table</span>
<span class="sd">        &gt;&gt;&gt; all_sky = MOC.from_str(&quot;0/0-11&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # Let&#39;s create a meaningless multiorder map</span>
<span class="sd">        &gt;&gt;&gt; uniq = [4 * 4**4 + x for x in range(20)]</span>
<span class="sd">        &gt;&gt;&gt; rng = np.random.default_rng(0)</span>
<span class="sd">        &gt;&gt;&gt; probdensity = rng.random(20) / 100</span>
<span class="sd">        &gt;&gt;&gt; multi_order_map = Table([uniq, probdensity], names=(&quot;UNIQ&quot;, &quot;PROBDENSITY&quot;))</span>
<span class="sd">        &gt;&gt;&gt; # The probability to be in the intersection with the all sky is</span>
<span class="sd">        &gt;&gt;&gt; round(all_sky.probability_in_multiordermap(multi_order_map), 4)</span>
<span class="sd">        0.0004</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        probabilities_in_multiordermap: makes this calculation for a list of MOCs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_index</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">multiorder_probdens_map_sum_in_smoc</span><span class="p">(</span>
                <span class="n">index</span><span class="p">,</span>
                <span class="o">*</span><span class="n">_extract_mask_and_values_multiordermap</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="s2">&quot;PROBDENSITY&quot;</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">multiordermap_sum_in_smoc_from_file</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">))</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;An argument of type &#39;str&#39;, &#39;pathlib.Path&#39;, or &#39;astropy.table.Table&#39;&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; is expected. Got &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.sum_in_multiordermap">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.sum_in_multiordermap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sum_in_multiordermap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiordermap</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the sum of a column from a multiordermap in the intersection with the MOC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiordermap : astropy.table.Table</span>
<span class="sd">            The table should have a column ``UNIQ`` that corresponds to HEALPix cells</span>
<span class="sd">            in the uniq notation.</span>
<span class="sd">        column : str</span>
<span class="sd">            The name of the column to sum. It should be compatible with a float conversion.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The sum of the values in the intersection between the MOC and the</span>
<span class="sd">            multiorder map coverages.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from astropy.table import Table</span>
<span class="sd">        &gt;&gt;&gt; all_sky = MOC.from_str(&quot;0/0-11&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # Let&#39;s create a meaningless multiorder map</span>
<span class="sd">        &gt;&gt;&gt; uniq = [4 * 4**5 + x for x in np.arange(200)]</span>
<span class="sd">        &gt;&gt;&gt; rng = np.random.default_rng(0)</span>
<span class="sd">        &gt;&gt;&gt; column = rng.random(200)</span>
<span class="sd">        &gt;&gt;&gt; multi_order_map = Table([uniq, column], names=(&quot;UNIQ&quot;, &quot;column&quot;))</span>
<span class="sd">        &gt;&gt;&gt; round(all_sky.sum_in_multiordermap(multi_order_map, &quot;column&quot;), 4)</span>
<span class="sd">        107.9259</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_index</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">multiordermap_sum_in_smoc</span><span class="p">(</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="o">*</span><span class="n">_extract_mask_and_values_multiordermap</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="n">column</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.values_and_weights_in_multiordermap">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.values_and_weights_in_multiordermap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">values_and_weights_in_multiordermap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiordermap</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the sum of a column from a multiordermap in the intersection with the MOC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiordermap : astropy.table.Table</span>
<span class="sd">            The table should have a column ``UNIQ`` that corresponds to HEALPix cells</span>
<span class="sd">            in the uniq notation.</span>
<span class="sd">        column : str</span>
<span class="sd">            The name of the column to return. It should be compatible with a float conversion.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple(np.ndarray, np.ndarray)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_index</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">multiorder_values_and_weights_in_smoc</span><span class="p">(</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="o">*</span><span class="n">_extract_mask_and_values_multiordermap</span><span class="p">(</span><span class="n">multiordermap</span><span class="p">,</span> <span class="n">column</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.mask_uniq">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.mask_uniq">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mask_uniq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uniq</span><span class="p">,</span> <span class="n">uniq_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fully_covered_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a mask for an array of uniq cells intersecting the MOC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uniq : `~np.array`</span>
<span class="sd">            An array on integers corresponding to HEALPix cells in the uniq notation.</span>
<span class="sd">        uniq_mask : `~np.array`, optional</span>
<span class="sd">            An optional array to mask the uniq array. Set to True where the values of the</span>
<span class="sd">            uniq array should be ignored (following the numpy `~np.ma.masked_array`</span>
<span class="sd">            convention).</span>
<span class="sd">        fully_covered_only : bool, optional</span>
<span class="sd">            If True, keep only uniq cells that are fully covered by the MOC.</span>
<span class="sd">            Otherwise, also keep cells that intersect the MOC.</span>
<span class="sd">            By default False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~np.array`</span>
<span class="sd">            A mask that is True where the uniq cell is comprised (or at least intersects</span>
<span class="sd">            depending on &#39;fully_covered_only&#39;) in the MOC and False otherwise</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; uniq = [4 * 4**3 + x for x in range(8)] # corresponds to 3/0-7</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_str(&quot;3/4-20&quot;)</span>
<span class="sd">        &gt;&gt;&gt; moc.mask_uniq(uniq) # the first four cells are NOT intersecting</span>
<span class="sd">        array([False, False, False, False,  True,  True,  True,  True])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_index</span>
        <span class="k">if</span> <span class="n">uniq_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">uniq_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uniq_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uniq_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mocpy</span><span class="o">.</span><span class="n">multiorder_filter_mask_in_smoc</span><span class="p">(</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uniq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">),</span>
            <span class="n">uniq_mask</span><span class="p">,</span>
            <span class="n">fully_covered_only</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">uniq_mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_valued_healpix_cells">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_valued_healpix_cells">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_valued_healpix_cells</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">uniq</span><span class="p">,</span>
        <span class="n">values</span><span class="p">,</span>
        <span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">values_are_densities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cumul_from</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">cumul_to</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">asc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">no_split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">reverse_decent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a list of uniq associated with values.</span>

<span class="sd">        HEALPix cells are first sorted by their values.</span>
<span class="sd">        The MOC contains the cells from which the cumulative value is between</span>
<span class="sd">        ``cumul_from`` and ``cumul_to``.</span>
<span class="sd">        Cells being on the fence are recursively splitted and added</span>
<span class="sd">        until the depth of the cells is equal to ``max_norder``.</span>

<span class="sd">        For compatibility with Aladin, use ``no_split=False`` and ``reverse_decent=True``</span>

<span class="sd">        Remark: using ``no_split=False``, the way the cells overlapping with the low and high thresholds are split</span>
<span class="sd">        is somewhat arbitrary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uniq : `numpy.ndarray`</span>
<span class="sd">            HEALPix cell indices written in uniq. dtype must be np.uint64</span>
<span class="sd">        values : `numpy.ndarray`</span>
<span class="sd">            Value associated with each ``uniq`` cells. dtype must be np.float64</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            The max depth of the MOC, should be at least as large as the depth corresponding of the smallest HEALPix cell found in ``uniq``.</span>
<span class="sd">            Warnings:</span>
<span class="sd">            1 - the depth of the returned MOC will be at least as deep as the smallest HEALPix cell found in ``uniq``.</span>
<span class="sd">            2 - contrary to MOCPy before v0.12, the user has to degrade the MOC if `max_depth` &lt; smallest HEALPix cell depth.</span>
<span class="sd">        values_are_densities: tell whether the values depend on the cell area or not</span>
<span class="sd">        cumul_from : float</span>
<span class="sd">            Cumulative value from which cells will be added to the MOC</span>
<span class="sd">        cumul_to : float</span>
<span class="sd">            Cumulative value to which cells will be added to the MOC</span>
<span class="sd">        asc: boolean</span>
<span class="sd">            the cumulative value is computed from lower to highest densities instead of from highest to lowest</span>
<span class="sd">        strict: boolean</span>
<span class="sd">            (sub-)cells overlapping the `cumul_from` or `cumul_to` values are not added</span>
<span class="sd">        no_split: boolean</span>
<span class="sd">            cells overlapping the `cumul_from` or `cumul_to` values are not recursively split</span>
<span class="sd">        reverse_decent: boolean</span>
<span class="sd">            perform the recursive decent from the highest cell number to the lowest (to be compatible with Aladin)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;To avoid an extra loop, it is preferable to provide the max_depth parameter.&quot;</span>
                <span class="s2">&quot;It will probably become mandatory in future releases.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">uniq</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">max_depth</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">max_depth</span> <span class="o">&gt;</span> <span class="mi">29</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid uniq numbers. Too big uniq or negative uniq numbers might be the cause.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">_mask_unsigned_before_casting</span><span class="p">(</span><span class="n">uniq</span><span class="p">)</span>
        <span class="c1"># if any of the values in uniq are negative</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">uniq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uniq</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_valued_hpx_cells</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
            <span class="n">uniq</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">),</span>
            <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
            <span class="n">values_are_densities</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cumul_from</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cumul_to</span><span class="p">),</span>
            <span class="n">asc</span><span class="p">,</span>
            <span class="n">strict</span><span class="p">,</span>
            <span class="n">no_split</span><span class="p">,</span>
            <span class="n">reverse_decent</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_elliptical_cone">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_elliptical_cone">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_elliptical_cone</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">delta_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from an elliptical cone.</span>

<span class="sd">        The ellipse is centered around the (`lon`, `lat`) position. `a` (resp. `b`) corresponds</span>
<span class="sd">        to the semi-major axis magnitude (resp. semi-minor axis magnitude). `pa` is expressed as a</span>
<span class="sd">        `~astropy.coordinates.Angle` and defines the position angle of the elliptical cone.</span>
<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the convention for Space MOCs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The longitude of the center of the elliptical cone.</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The latitude of the center of the elliptical cone.</span>
<span class="sd">        a : `astropy.coordinates.Angle`</span>
<span class="sd">            The semi-major axis angle of the elliptical cone.</span>
<span class="sd">        b : `astropy.coordinates.Angle`</span>
<span class="sd">            The semi-minor axis angle of the elliptical cone.</span>
<span class="sd">        pa : `astropy.coordinates.Angle`</span>
<span class="sd">            The position angle (i.e. the angle between the north and the semi-major axis, east-of-north).</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>
<span class="sd">        delta_depth : int, optional</span>
<span class="sd">            To control the approximation, you can choose to perform the computations at a deeper</span>
<span class="sd">            depth using the `delta_depth` parameter.</span>
<span class="sd">            The depth at which the computations will be made will therefore be equal to</span>
<span class="sd">            `depth` + `delta_depth`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import Angle, Longitude, Latitude</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_elliptical_cone(</span>
<span class="sd">        ...  lon=Longitude(0 * u.deg),</span>
<span class="sd">        ...  lat=Latitude(0 * u.deg),</span>
<span class="sd">        ...  a=Angle(10, u.deg),</span>
<span class="sd">        ...  b=Angle(5, u.deg),</span>
<span class="sd">        ...  pa=Angle(0, u.deg),</span>
<span class="sd">        ...  max_depth=10</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_elliptical_cone</span><span class="p">(</span>
            <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_cone">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_cone">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_cone</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">delta_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a cone.</span>

<span class="sd">        The cone is centered around the (`lon`, `lat`) position with a radius expressed by</span>
<span class="sd">        `radius`.</span>
<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The longitude of the center of the cone.</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The latitude of the center of the cone.</span>
<span class="sd">        radius : `astropy.coordinates.Angle`</span>
<span class="sd">            The radius angle of the cone.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>
<span class="sd">        delta_depth : int, optional</span>
<span class="sd">            To control the approximation, you can choose to perform the computations at a deeper</span>
<span class="sd">            depth using the `delta_depth` parameter.</span>
<span class="sd">            The depth at which the computations will be made will therefore be equal to</span>
<span class="sd">            `max_depth` + `delta_depth`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import Angle, Longitude, Latitude</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_cone(</span>
<span class="sd">        ...  lon=Longitude(0 * u.deg),</span>
<span class="sd">        ...  lat=Latitude(0 * u.deg),</span>
<span class="sd">        ...  radius=Angle(10, u.deg),</span>
<span class="sd">        ...  max_depth=10</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;MOC.from_cone&#39; only works with one cone. To create MOCs &quot;</span>
                <span class="s2">&quot;from multiple cones, use &#39;MOC.from_cones&#39;.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_cone</span><span class="p">(</span>
            <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">radius</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
            <span class="n">delta_depth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_cones">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_cones">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_cones</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">lon</span><span class="p">,</span>
        <span class="n">lat</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">,</span>
        <span class="n">max_depth</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">union_strategy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delta_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">n_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of MOCs from cones.</span>

<span class="sd">        Each cone is centered around the (`lon`, `lat`) position with a radius expressed by</span>
<span class="sd">        `radius`.</span>
<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The longitude of the center of the cone. Can be scalar or a list of longitudes.</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The latitude of the center of the cone. Can be scalar or a list of latitudes.</span>
<span class="sd">        radius : `astropy.coordinates.Angle` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The radius angle of the cone. Can be scalar or a list of radii.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>
<span class="sd">        union_strategy : str, optional</span>
<span class="sd">            Return the union of all the cones instead of the list of MOCs. Can be either</span>
<span class="sd">            &quot;small_cones&quot; or &quot;large_cones&quot;. The &quot;small_cone&quot; strategy will be faster for</span>
<span class="sd">            non-overlapping cones and the &quot;large_cones&quot; for the other case.</span>
<span class="sd">        delta_depth : int, optional</span>
<span class="sd">            To control the approximation, you can choose to perform the computations at a deeper</span>
<span class="sd">            depth using the `delta_depth` parameter.</span>
<span class="sd">            The depth at which the computations will be made will therefore be equal to</span>
<span class="sd">            `max_depth` + `delta_depth`.</span>
<span class="sd">        n_threads : int, optional</span>
<span class="sd">            The number of threads to be used. If this is set to None (default value),</span>
<span class="sd">            all available threads will be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[`~mocpy.MOC`] or `~mocpy.MOC`</span>
<span class="sd">            The resulting list of MOCs, or if &#39;union_strategy&#39; is not None, the MOC of the</span>
<span class="sd">            union of all the cones.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_cones(</span>
<span class="sd">        ...  lon=[1, 4] * u.deg,</span>
<span class="sd">        ...  lat=[2, 5] * u.deg,</span>
<span class="sd">        ...  radius=1 * u.arcmin,</span>
<span class="sd">        ...  max_depth=12,</span>
<span class="sd">        ...  union_strategy=&quot;small_cones&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">union_strategy</span> <span class="o">==</span> <span class="s2">&quot;small_cones&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">radius</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
                <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">Angle</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">radii</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_small_cones</span><span class="p">(</span>
                <span class="n">lon</span><span class="p">,</span>
                <span class="n">lat</span><span class="p">,</span>
                <span class="n">radii</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">),</span>
                <span class="n">n_threads</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">union_strategy</span> <span class="o">==</span> <span class="s2">&quot;large_cones&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">radius</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
                <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">Angle</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">radii</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_large_cones</span><span class="p">(</span>
                <span class="n">lon</span><span class="p">,</span>
                <span class="n">lat</span><span class="p">,</span>
                <span class="n">radii</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">),</span>
                <span class="n">n_threads</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">union_strategy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;union_strategy&#39; can only be None, &#39;large_cones&#39;, or &#39;small_cones&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">radius</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_same_cones</span><span class="p">(</span>
                <span class="n">lon</span><span class="p">,</span>
                <span class="n">lat</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">Angle</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
                <span class="n">delta_depth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">),</span>
                <span class="n">n_threads</span><span class="o">=</span><span class="n">n_threads</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_cones</span><span class="p">(</span>
            <span class="n">lon</span><span class="p">,</span>
            <span class="n">lat</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">Angle</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
            <span class="n">delta_depth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">),</span>
            <span class="n">n_threads</span><span class="o">=</span><span class="n">n_threads</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="MOC.from_zone">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_zone">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_zone</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a zone.</span>

<span class="sd">        The zone is defined by a range of longitudes and latitudes. Its sides follow</span>
<span class="sd">        great circles in longitudes and small circles for latitudes.</span>
<span class="sd">        The bottom and left sides are included in the MOC, while the top and right sides</span>
<span class="sd">        are not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            A couple of coordinates for the bottom left and the upper right corner of the</span>
<span class="sd">            zone.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import SkyCoord</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_zone(</span>
<span class="sd">        ...  SkyCoord([[0, 0], [20, 20]], unit=&quot;deg&quot;),</span>
<span class="sd">        ...  max_depth=5</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># workaround astropy.SkyCoord that wraps longitudes between [0:360[</span>
        <span class="c1"># where we want ]0:360] for lon_max. There is no issue for lon_min that is</span>
        <span class="c1"># expected in [0:360[.</span>
        <span class="n">lon_max</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">deg</span>
        <span class="k">if</span> <span class="n">lon_max</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lon_max</span> <span class="o">=</span> <span class="mi">360</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_zone</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">lon_max</span><span class="p">,</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_box">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_box">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_box</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a box/rectangle.</span>

<span class="sd">        The box is centered around the (`lon`, `lat`) position. The sides and cross from</span>
<span class="sd">        the center follow great circles. As such, the box is the intersection between</span>
<span class="sd">        two orthogonal spherical wedges having the same center.</span>
<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `~astropy.coordinates.Longitude` or its supertype `~astropy.units.Quantity`</span>
<span class="sd">            The longitude of the center of the cone.</span>
<span class="sd">        lat : `~astropy.coordinates.Latitude` or its supertype `~astropy.units.Quantity`</span>
<span class="sd">            The latitude of the center of the cone.</span>
<span class="sd">        a : `~astropy.coordinates.Angle`</span>
<span class="sd">            The semi-major axis of the box, i.e. half of the box&#39;s width.</span>
<span class="sd">        b : `~astropy.coordinates.Angle`</span>
<span class="sd">            The semi-minor axis of the box, i.e. half of the box&#39;s height.</span>
<span class="sd">        angle : `astropy.coordinates.Angle`</span>
<span class="sd">            The tilt angle between the north and the semi-major axis, east of north.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import Angle, Longitude, Latitude</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_box(</span>
<span class="sd">        ...  lon=Longitude(&quot;0d&quot;),</span>
<span class="sd">        ...  lat=Latitude(&quot;0d&quot;),</span>
<span class="sd">        ...  a=Angle(&quot;10d&quot;),</span>
<span class="sd">        ...  b=Angle(&quot;2d&quot;),</span>
<span class="sd">        ...  angle=Angle(&quot;30d&quot;),</span>
<span class="sd">        ...  max_depth=10</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_box</span><span class="p">(</span>
            <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">angle</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_boxes">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_boxes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_boxes</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">union_strategy</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a box/rectangle.</span>

<span class="sd">        The boxes are centered around the (`lon`, `lat`) positions.</span>
<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `~astropy.coordinates.Longitude` or its supertype `~astropy.units.Quantity`</span>
<span class="sd">            The longitude of the center of the cone.</span>
<span class="sd">        lat : `~astropy.coordinates.Latitude` or its supertype `~astropy.units.Quantity`</span>
<span class="sd">            The latitude of the center of the cone.</span>
<span class="sd">        a : `~astropy.coordinates.Angle` or its supertype `~astropy.units.Quantity`</span>
<span class="sd">            The semi-major axis of the box, i.e. half of the box&#39;s width.</span>
<span class="sd">        b : `~astropy.coordinates.Angle` or its supertype `~astropy.units.Quantity`</span>
<span class="sd">            The semi-minor axis of the box, i.e. half of the box&#39;s height.</span>
<span class="sd">        angle : `astropy.coordinates.Angle` or its supertype `~astropy.units.Quantity`</span>
<span class="sd">            The tilt angle between the north and the semi-major axis, east of north.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>
<span class="sd">        n_threads : int, optional</span>
<span class="sd">            The number of threads to be used. If this is set to None (default value),</span>
<span class="sd">            all available threads will be used.</span>
<span class="sd">        union_strategy : str, optional</span>
<span class="sd">            Return the union of all the boxes instead of the list of MOCs. Can be either</span>
<span class="sd">            &quot;small_boxes&quot; or &quot;large_boxes&quot;. The &quot;small_boxes&quot; strategy will be faster for</span>
<span class="sd">            non-overlapping boxes and the &quot;large_boxes&quot; for the other case.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[`~mocpy.MOC`] or `~mocpy.MOC`</span>
<span class="sd">            The resulting list of MOCs. If &#39;union_strategy&#39; is not None, returns the MOC</span>
<span class="sd">            of the union of all boxes instead.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; # similar boxes, same size and orientation</span>
<span class="sd">        &gt;&gt;&gt; moc_list = MOC.from_boxes(</span>
<span class="sd">        ...  lon=[1, 2]*u.deg,</span>
<span class="sd">        ...  lat=[1, 2]*u.deg,</span>
<span class="sd">        ...  a=10*u.deg,</span>
<span class="sd">        ...  b=5*u.deg,</span>
<span class="sd">        ...  angle=30*u.deg,</span>
<span class="sd">        ...  max_depth=10</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; # different boxes</span>
<span class="sd">        &gt;&gt;&gt; moc_list = MOC.from_boxes(</span>
<span class="sd">        ...  lon=[1, 2]*u.deg,</span>
<span class="sd">        ...  lat=[1, 2]*u.deg,</span>
<span class="sd">        ...  a=[10, 20]*u.deg,</span>
<span class="sd">        ...  b=[5, 10]*u.deg,</span>
<span class="sd">        ...  angle=[30, 10]*u.deg,</span>
<span class="sd">        ...  max_depth=10,</span>
<span class="sd">        ...  union_strategy=&quot;small_boxes&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">angle</span><span class="p">]</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">isscalar</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;a&#39;, &#39;b&#39; and &#39;angle&#39; should either be all astropy angle-equivalent&quot;</span>
                    <span class="s2">&quot; scalar values or they should all be iterable angle-equivalent. &quot;</span>
                    <span class="s2">&quot;They cannot be a mix of both.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">union_strategy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_same_boxes</span><span class="p">(</span>
                    <span class="n">lon</span><span class="p">,</span>
                    <span class="n">lat</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">angle</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
                    <span class="n">max_depth</span><span class="p">,</span>
                    <span class="n">n_threads</span><span class="o">=</span><span class="n">n_threads</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="c1"># no exception for same boxes in the union case</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">Angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">Angle</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">Angle</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
        <span class="c1"># different boxes</span>
        <span class="k">if</span> <span class="n">union_strategy</span> <span class="o">==</span> <span class="s2">&quot;small_boxes&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="n">mocpy</span><span class="o">.</span><span class="n">from_small_boxes</span><span class="p">(</span>
                    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="n">n_threads</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">union_strategy</span> <span class="o">==</span> <span class="s2">&quot;large_boxes&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="n">mocpy</span><span class="o">.</span><span class="n">from_large_boxes</span><span class="p">(</span>
                    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="n">n_threads</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">union_strategy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;union_strategy&#39; can only be None, &#39;large_boxes&#39;, or &#39;small_boxes&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_boxes</span><span class="p">(</span>
            <span class="n">lon</span><span class="p">,</span>
            <span class="n">lat</span><span class="p">,</span>
            <span class="n">a</span><span class="p">,</span>
            <span class="n">b</span><span class="p">,</span>
            <span class="n">angle</span><span class="p">,</span>
            <span class="n">max_depth</span><span class="p">,</span>
            <span class="n">n_threads</span><span class="o">=</span><span class="n">n_threads</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="MOC.from_ring">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_ring">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_ring</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">lon</span><span class="p">,</span>
        <span class="n">lat</span><span class="p">,</span>
        <span class="n">internal_radius</span><span class="p">,</span>
        <span class="n">external_radius</span><span class="p">,</span>
        <span class="n">max_depth</span><span class="p">,</span>
        <span class="n">delta_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a ring.</span>

<span class="sd">        The cone is centered around the (`lon`, `lat`) position with an internal radius expressed by</span>
<span class="sd">        `internal_radius` and an external radius expressed by `external_radius`.</span>
<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The longitude of the center of the ring.</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The latitude of the center of the ring.</span>
<span class="sd">        internal_radius : `astropy.coordinates.Angle`</span>
<span class="sd">            The internal radius angle of the ring.</span>
<span class="sd">        external_radius : `astropy.coordinates.Angle`</span>
<span class="sd">            The external radius angle of the ring.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>
<span class="sd">        delta_depth : int, optional</span>
<span class="sd">            To control the approximation, you can choose to perform the computations at a deeper</span>
<span class="sd">            depth using the `delta_depth` parameter.</span>
<span class="sd">            The depth at which the computations will be made will therefore be equal to</span>
<span class="sd">            `max_depth` + `delta_depth`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import Angle, Longitude, Latitude</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_ring(</span>
<span class="sd">        ...  lon=Longitude(0 * u.deg),</span>
<span class="sd">        ...  lat=Latitude(0 * u.deg),</span>
<span class="sd">        ...  internal_radius=Angle(5, u.deg),</span>
<span class="sd">        ...  external_radius=Angle(10, u.deg),</span>
<span class="sd">        ...  max_depth=10</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_ring</span><span class="p">(</span>
            <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">internal_radius</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">external_radius</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_polygon_skycoord">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_polygon_skycoord">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_polygon_skycoord</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">skycoord</span><span class="p">,</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a polygon.</span>

<span class="sd">        The polygon is given as an `astropy.coordinates.SkyCoord` that contains the</span>
<span class="sd">        vertices of the polygon. Concave, convex and self-intersecting polygons are accepted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skycoord : `astropy.coordinates.SkyCoord`</span>
<span class="sd">            The sky coordinates defining the vertices of a polygon.</span>
<span class="sd">        complement : return the complement of the polygon. Set to False by default.</span>
<span class="sd">            The default polygon is the smallest one.</span>
<span class="sd">        max_depth : int, optional</span>
<span class="sd">            The resolution of the MOC. Set to 10 by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import SkyCoord</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; MOC.from_polygon_skycoord(SkyCoord([80, 82, 76], [36, 33, 33], unit=&quot;deg&quot;)) # doctest: +ELLIPSIS</span>
<span class="sd">        6/1293</span>
<span class="sd">        7/5149-5151 5165 5169-5171 5176-5177 5180-5181 5186 5192 5194 5216 5218-5219</span>
<span class="sd">        ...</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_polygon</span>
<span class="sd">        from_polygons</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_polygon</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="n">skycoord</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
            <span class="n">lat</span><span class="o">=</span><span class="n">skycoord</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
            <span class="n">complement</span><span class="o">=</span><span class="n">complement</span><span class="p">,</span>
            <span class="n">max_depth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_polygons">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_polygons">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_polygons</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">list_vertices</span><span class="p">,</span>
        <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">n_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of MOCs list from a list of polygons.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        list_vertices : list[`~astropy.coordinates.SkyCoord`] OR numpy.ndarray</span>
<span class="sd">            If list_vertices is a list of `~astropy.coordinates.SkyCoord` objects, each</span>
<span class="sd">            SkyCoord object should contain more than three vertices and they should each</span>
<span class="sd">            describe a polygon.</span>
<span class="sd">            If list_vertices is a numpy.ndarray, it should be in the form</span>
<span class="sd">            [lon_array1, lat_array1, lon_array2, lat_array2, lon_array3, lat_array3, ...].</span>
<span class="sd">            They should be valid longitudes and latitudes in degrees in ICRS.</span>
<span class="sd">        complement : return the complement of the polygon. Set to False by default.</span>
<span class="sd">            The default polygon is the smallest one.</span>
<span class="sd">        max_depth : int, optional</span>
<span class="sd">            The resolution of the MOC. Set to 10 by default.</span>
<span class="sd">        n_threads : int, optional</span>
<span class="sd">            The number of threads to be used. If this is set to None (default value),</span>
<span class="sd">            all available threads will be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[`mocpy.MOC`]</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import SkyCoord</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; list_vertices = [</span>
<span class="sd">        ...     SkyCoord([-4, 4, 4, -4], [4, 4, -4, -4], unit=&quot;deg&quot;),</span>
<span class="sd">        ...     SkyCoord([0, 6, 0, -6], [6, 0, -6, 0], unit=&quot;deg&quot;)</span>
<span class="sd">        ... ]</span>
<span class="sd">        &gt;&gt;&gt; list_mocs = MOC.from_polygons(list_vertices)</span>
<span class="sd">        &gt;&gt;&gt; # without the SkyCoord object, we need to adapt the coordinates</span>
<span class="sd">        &gt;&gt;&gt; list_vertices = [[356, 4, 4, 356], [4, 4, -4, -4],</span>
<span class="sd">        ...                  [0, 6, 0, 354], [6, 0, -6, 0]]</span>
<span class="sd">        &gt;&gt;&gt; list_mocs_no_check_no_wrap = MOC.from_polygons(list_vertices)</span>
<span class="sd">        &gt;&gt;&gt; list_mocs == list_mocs_no_check_no_wrap</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_polygon</span>
<span class="sd">        from_polygon_skycoord</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SkyCoord</span><span class="p">):</span>
            <span class="n">lon_lat_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_vertices</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">icrs</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_polygons</span><span class="p">(</span>
                <span class="n">lon_lat_list</span><span class="p">,</span>
                <span class="n">complement</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
                <span class="n">n_threads</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is the unsafe version where the users should provide correct coordinates</span>
            <span class="c1"># without checks on our side</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_polygons</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="n">complement</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
                <span class="n">n_threads</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="MOC.from_polygon">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_polygon">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@validate_lonlat</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_polygon</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">complement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a polygon.</span>

<span class="sd">        The polygon is given as lon and lat `astropy.units.Quantity` that define the</span>
<span class="sd">        vertices of the polygon. Concave, convex and self-intersecting polygons are accepted.</span>
<span class="sd">        The coordinates should be expressed in equatorial coordinates using the</span>
<span class="sd">        ICRS reference. We follow the Space MOC standard.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon : `astropy.coordinates.Longitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The longitudes defining the polygon.</span>
<span class="sd">        lat : `astropy.coordinates.Latitude` or its supertype `astropy.units.Quantity`</span>
<span class="sd">            The latitudes defining the polygon. Can describe convex and concave</span>
<span class="sd">            polygons but not self-intersecting ones.</span>
<span class="sd">        complement : return the complement of the polygon. Set to False by default.</span>
<span class="sd">            The default polygon is the smallest one.</span>
<span class="sd">        max_depth : int, optional</span>
<span class="sd">            The resolution of the MOC. Set to 10 by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_polygons</span>
<span class="sd">        from_polygons_skycoord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_polygon</span><span class="p">(</span>
            <span class="n">lon</span><span class="p">,</span>
            <span class="n">lat</span><span class="p">,</span>
            <span class="n">complement</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_stcs">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_stcs">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_stcs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">stcs</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">delta_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a STC-S.</span>

<span class="sd">        Time, Spectral and Redshift sub-phrases are ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stcs : str</span>
<span class="sd">            The STC-S string.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            Maximum HEALPix cell resolution.</span>
<span class="sd">        delta_depth : int, optional</span>
<span class="sd">            To control the approximation, you can choose to perform the computations at a deeper</span>
<span class="sd">            depth using the `delta_depth` parameter.</span>
<span class="sd">            The depth at which the computations will be made will therefore be equal to</span>
<span class="sd">            `max_depth` + `delta_depth`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The resulting MOC</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; moc1 = MOC.from_stcs(&quot;Circle ICRS 147.6 69.9 0.4&quot;, max_depth=14)</span>
<span class="sd">        &gt;&gt;&gt; moc2 = MOC.from_cone(lon=147.6 * u.deg, lat=69.9 * u.deg,</span>
<span class="sd">        ...                      radius=Angle(0.4, u.deg), max_depth=14)</span>
<span class="sd">        &gt;&gt;&gt; moc1 == moc2</span>
<span class="sd">        True</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        There is so far no implicit conversion, so the STC-S string will be rejected if:</span>
<span class="sd">        * the frame is different from `ICRS`</span>
<span class="sd">        * the flavor is different from `Spher2`</span>
<span class="sd">        * the units are different from `degrees`</span>
<span class="sd">        The implementation is not (yet?) fully compliant with the STC standard (see MOC Lib rust for more details):</span>
<span class="sd">        * DIFFERENCE is so far interpreted as a symmetrical difference (XOR) while it is a MINUS in the STC standard</span>
<span class="sd">        * Self-intersecting Polygons are supported, and the &quot;interior&quot; usually has the smallest area</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_stcs</span><span class="p">(</span><span class="n">stcs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">delta_depth</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_astropy_regions">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_astropy_regions">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_astropy_regions</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a SMOC from an astropy regions.</span>

<span class="sd">        This creates the MOC of the requested order that contains entirely the astropy</span>
<span class="sd">        region. See https://github.com/astropy/regions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region : `~regions.SkyRegion`</span>
<span class="sd">            The supported sky regions are `~regions.CircleSkyRegion`,</span>
<span class="sd">            `~regions.CircleAnnulusSkyRegion`, `~regions.EllipseSkyRegion`,</span>
<span class="sd">            `~regions.RectangleSkyRegion`, `~regions.PolygonSkyRegion`,</span>
<span class="sd">            `~regions.PointSkyRegion`, `~regions.Regions`.</span>
<span class="sd">        max_depth : int</span>
<span class="sd">            The maximum HEALPix cell resolution of the MOC. Should be comprised between</span>
<span class="sd">            0 and 29.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For the `~regions.Regions`, the returned MOC will be the union of all the regions.</span>
<span class="sd">        - For the `~regions.PolygonSkyRegion` and the `~regions.RectangleSkyRegion`, the MOC</span>
<span class="sd">          will consider the sides to follow great circles on the sky sphere while in</span>
<span class="sd">          astropy-regions the sides follow straight lines in the projected space (depending on</span>
<span class="sd">          a given WCS, see issue https://github.com/astropy/regions/issues/564).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import SkyCoord</span>
<span class="sd">        &gt;&gt;&gt; point = SkyCoord(&quot;+23h20m48.3s +61d12m06s&quot;)</span>
<span class="sd">        &gt;&gt;&gt; point_region = regions.PointSkyRegion(point)</span>
<span class="sd">        &gt;&gt;&gt; moc_point = MOC.from_astropy_regions(point_region, max_depth=10)</span>
<span class="sd">        &gt;&gt;&gt; moc_point</span>
<span class="sd">        10/3663728</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">supported_regions_types</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">regions</span><span class="o">.</span><span class="n">CircleSkyRegion</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">.</span><span class="n">CircleAnnulusSkyRegion</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">.</span><span class="n">EllipseSkyRegion</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">.</span><span class="n">RectangleSkyRegion</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">.</span><span class="n">PolygonSkyRegion</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">.</span><span class="n">PointSkyRegion</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">.</span><span class="n">Regions</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">CircleSkyRegion</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">icrs</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_cone</span><span class="p">(</span>
                <span class="n">center</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
                <span class="n">center</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="n">region</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">CircleAnnulusSkyRegion</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">icrs</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_ring</span><span class="p">(</span>
                <span class="n">center</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
                <span class="n">center</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
                <span class="n">internal_radius</span><span class="o">=</span><span class="n">region</span><span class="o">.</span><span class="n">inner_radius</span><span class="p">,</span>
                <span class="n">external_radius</span><span class="o">=</span><span class="n">region</span><span class="o">.</span><span class="n">outer_radius</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">EllipseSkyRegion</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">icrs</span>
            <span class="k">if</span> <span class="n">region</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">angle</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Angle</span><span class="p">(</span><span class="s2">&quot;90d&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_elliptical_cone</span><span class="p">(</span>
                <span class="n">center</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
                <span class="n">center</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
                <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
                <span class="n">pa</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">RectangleSkyRegion</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">icrs</span>
            <span class="k">if</span> <span class="n">region</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">angle</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Angle</span><span class="p">(</span><span class="s2">&quot;90d&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_box</span><span class="p">(</span>
                <span class="n">center</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
                <span class="n">center</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
                <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
                <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">PolygonSkyRegion</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_polygon_skycoord</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">PointSkyRegion</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_skycoords</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">max_norder</span><span class="o">=</span><span class="n">max_depth</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">regions</span><span class="o">.</span><span class="n">Regions</span><span class="p">):</span>
            <span class="n">mocs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">from_astropy_regions</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">region</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mocs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">mocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">mocs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># fastest multi-union</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;from_astropy_regions&#39; does not support this region type.&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The supported regions are: </span><span class="si">{</span><span class="n">supported_regions_types</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MOC.new_empty">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.new_empty">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">new_empty</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new empty MOC of given depth.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_depth : int, The resolution of the MOC</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moc : `~mocpy.MOC`</span>
<span class="sd">            The MOC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">new_empty_smoc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_healpix_cells">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_healpix_cells">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_healpix_cells</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ipix</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a set of HEALPix cells at various depths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ipix : `numpy.ndarray`</span>
<span class="sd">            HEALPix cell indices in the NESTED notation. dtype must be np.uint64</span>
<span class="sd">        depth : `numpy.ndarray` or int</span>
<span class="sd">            Depth of the HEALPix cells. Must be of the same size of `ipix`.</span>
<span class="sd">            dtype must be np.uint8. Corresponds to the `level` of an HEALPix cell in astropy.healpix.</span>
<span class="sd">        max_depth : int, The resolution of the MOC (degrades on the fly input cells if necessary)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            When `ipix` and `depth` do not have the same shape</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">            The MOC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ipix</span><span class="p">),</span> <span class="n">depth</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">_mask_unsigned_before_casting</span><span class="p">(</span><span class="n">ipix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ipix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ipix</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">depth</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_healpix_cells</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ipix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_depth29_ranges">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_depth29_ranges">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_depth29_ranges</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MOC from a set of ranges of HEALPix Nested indices at order 29.</span>

<span class="sd">        For each range, the lower bound is inclusive and the upper bound is exclusive.</span>
<span class="sd">        The range `[0, 12*4^29[` represents the full-sky.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_depth : int, The resolution of the MOC</span>
<span class="sd">        ranges : `~numpy.ndarray`, optional</span>
<span class="sd">                a N x 2 numpy array representing the set of depth 29 HEALPix nested ranges.</span>
<span class="sd">                defaults to `np.zeros((0, 2), dtype=np.uint64)`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moc : `~mocpy.MOC`</span>
<span class="sd">            The MOC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span> <span class="k">if</span> <span class="n">ranges</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ranges</span>

        <span class="k">if</span> <span class="n">ranges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expected a N x 2 numpy array for ranges&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ranges</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">from_hpx_ranges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">max_depth</span><span class="p">),</span> <span class="n">ranges</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_stmoc_time_fold">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_stmoc_time_fold">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_stmoc_time_fold</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tmoc</span><span class="p">,</span> <span class="n">stmoc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a new S-MOC from the fold operation of the given ST-MOC by the given T-MOC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tmoc : `~mocpy.TimeMOC`</span>
<span class="sd">        stmoc : `~mocpy.STMOC`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">store_index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">project_on_stmoc_space_dim</span><span class="p">(</span>
            <span class="n">tmoc</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">stmoc</span><span class="o">.</span><span class="n">store_index</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">store_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.from_sfmoc_frequency_fold">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_sfmoc_frequency_fold">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_sfmoc_frequency_fold</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fmoc</span><span class="p">,</span> <span class="n">sfmoc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a S-MOC from the fold operation of the given SF-MOC by the given F-MOC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fmoc : `~mocpy.FrequencyMOC`</span>
<span class="sd">        sfmoc : `~mocpy.SFMOC`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~mocpy.MOC`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC, FrequencyMOC, SFMOC</span>
<span class="sd">        &gt;&gt;&gt; sfmoc = SFMOC.from_string(&#39;&#39;&#39;</span>
<span class="sd">        ... f15/0-10</span>
<span class="sd">        ... s12/0-100</span>
<span class="sd">        ... f15/11-20</span>
<span class="sd">        ... s12/101-200</span>
<span class="sd">        ... &#39;&#39;&#39;)</span>
<span class="sd">        &gt;&gt;&gt; fmoc = FrequencyMOC.from_string(&quot;15/0-2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; MOC.from_sfmoc_frequency_fold(fmoc, sfmoc)</span>
<span class="sd">        9/0</span>
<span class="sd">        10/4-5</span>
<span class="sd">        11/24</span>
<span class="sd">        12/100</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">store_index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">project_on_sfmoc_space_dim</span><span class="p">(</span>
            <span class="n">fmoc</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">sfmoc</span><span class="o">.</span><span class="n">store_index</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">store_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.order_to_spatial_resolution">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.order_to_spatial_resolution">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">order_to_spatial_resolution</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a depth to its equivalent spatial resolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : int</span>
<span class="sd">            Spatial depth.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spatial_resolution : `~astropy.coordinates.Angle`</span>
<span class="sd">            Spatial resolution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">**</span> <span class="p">(</span><span class="n">order</span><span class="p">))),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;rad&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.spatial_resolution_to_order">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.spatial_resolution_to_order">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spatial_resolution_to_order</span><span class="p">(</span><span class="n">spatial_resolution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a spatial resolution to a MOC order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spatial_resolution : `~astropy.coordinates.Angle`</span>
<span class="sd">            Spatial resolution</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        order : int</span>
<span class="sd">            The order corresponding to the spatial resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_rad</span> <span class="o">=</span> <span class="n">spatial_resolution</span><span class="o">.</span><span class="n">rad</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">res_rad</span> <span class="o">*</span> <span class="n">res_rad</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fits_header_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;PIXTYPE&quot;</span><span class="p">:</span> <span class="s2">&quot;HEALPIX&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ORDERING&quot;</span><span class="p">:</span> <span class="s2">&quot;NUNIQ&quot;</span><span class="p">,</span>
            <span class="s2">&quot;COORDSYS&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;reference frame (C=ICRS)&quot;</span><span class="p">),</span>
            <span class="s2">&quot;MOCORDER&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">,</span>
            <span class="s2">&quot;MOCTOOL&quot;</span><span class="p">:</span> <span class="s2">&quot;MOCPy&quot;</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fits_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span>
        <span class="k">return</span> <span class="s2">&quot;1J&quot;</span> <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="mi">13</span> <span class="k">else</span> <span class="s2">&quot;1K&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sky_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sky fraction covered by the MOC.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; MOC.from_string(&quot;0/0-11&quot;).sky_fraction # all sky</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">coverage_fraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">)</span>

    <span class="c1"># TODO : move this in astroquery.Simbad.query_region</span>
    <span class="c1"># See https://github.com/astropy/astroquery/pull/1466</span>
<div class="viewcode-block" id="MOC.query_simbad">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.query_simbad">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">query_simbad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query a view of SIMBAD data for SIMBAD objects in the coverage of the MOC instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_rows : int, optional</span>
<span class="sd">                maximum number of row returned</span>
<span class="sd">        timeout : float, optional</span>
<span class="sd">                timeout before aborting the query, default to 1000s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="s2">&quot;SIMBAD&quot;</span><span class="p">,</span> <span class="n">max_rows</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span></div>


    <span class="c1"># TODO : move this in astroquery.Vizier.query_region</span>
    <span class="c1"># See https://github.com/astropy/astroquery/pull/1466</span>
<div class="viewcode-block" id="MOC.query_vizier_table">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.query_vizier_table">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">query_vizier_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">max_rows</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query a VizieR table for sources in the coverage of the MOC instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table_id : str</span>
<span class="sd">                corresponds to a VizieR table id</span>
<span class="sd">        max_rows : int, optional</span>
<span class="sd">                maximum number of row returned</span>
<span class="sd">        timeout : float, optional</span>
<span class="sd">                timeout before aborting the query, default to 1000s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="n">table_id</span><span class="p">,</span> <span class="n">max_rows</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span></div>


    <span class="c1"># TODO : move this in astroquery</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resource_id</span><span class="p">,</span> <span class="n">max_rows</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Query Simbad or a VizieR table.</span>

<span class="sd">        Find sources in the coverage of the MOC instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.io.votable</span><span class="w"> </span><span class="kn">import</span> <span class="n">parse_single_table</span>

        <span class="n">moc_file</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="n">moc_fits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;fits&quot;</span><span class="p">,</span> <span class="n">pre_v2</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">moc_fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">moc_file</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
            <span class="s2">&quot;http://cdsxmatch.u-strasbg.fr/QueryCat/QueryCat&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="s2">&quot;mocfile&quot;</span><span class="p">,</span>
                <span class="s2">&quot;catName&quot;</span><span class="p">:</span> <span class="n">resource_id</span><span class="p">,</span>
                <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;votable&quot;</span><span class="p">,</span>
                <span class="s2">&quot;limit&quot;</span><span class="p">:</span> <span class="n">max_rows</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">files</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;moc&quot;</span><span class="p">:</span> <span class="n">moc_file</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()},</span>
            <span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;User-Agent&quot;</span><span class="p">:</span> <span class="s2">&quot;MOCPy&quot;</span><span class="p">},</span>
            <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">votable</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="n">votable</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parse_single_table</span><span class="p">(</span><span class="n">votable</span><span class="p">)</span><span class="o">.</span><span class="n">to_table</span><span class="p">()</span>

<div class="viewcode-block" id="MOC.wcs">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.wcs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wcs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fig</span><span class="p">,</span>
        <span class="n">coordsys</span><span class="o">=</span><span class="s2">&quot;icrs&quot;</span><span class="p">,</span>
        <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;AIT&quot;</span><span class="p">,</span>
        <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a wcs that can be given to matplotlib to plot the MOC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fig : `~matplotlib.pyplot.figure`</span>
<span class="sd">            The matplotlib figure used for plotting the MOC.</span>
<span class="sd">        coordsys : str, optional</span>
<span class="sd">            Coordinate system. Default to &quot;icrs&quot;. Must be in [&quot;icrs&quot;, &quot;galactic&quot;].</span>
<span class="sd">        projection : str, optional</span>
<span class="sd">            World base -&gt; Image base projection type.</span>
<span class="sd">            See http://docs.astropy.org/en/stable/wcs/#supported-projections for</span>
<span class="sd">            the projections currently supported in astropy. Default to Aitoff.</span>
<span class="sd">        rotation : `~astropy.coordinates.Angle`, optional</span>
<span class="sd">            The angle of rotation. Default to no rotation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wcs : `~astropy.wcs.WCS`</span>
<span class="sd">            The WCS that can be passed to mocpy.MOC.fill/border.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from mocpy import MOC</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; moc = MOC.from_str(&quot;2/2-25 28 29 4/0 6/&quot;)</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; moc.wcs(fig) # doctest: +SKIP</span>
<span class="sd">        WCS Keywords</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        Number of WCS axes: 2</span>
<span class="sd">        CTYPE : &#39;RA---AIT&#39;  &#39;DEC--AIT&#39;</span>
<span class="sd">        CRVAL : 92.29966711743452  54.33295312309193</span>
<span class="sd">        CRPIX : 320.5  240.5</span>
<span class="sd">        PC1_1 PC1_2  : 1.0  -0.0</span>
<span class="sd">        PC2_1 PC2_2  : 0.0  1.0</span>
<span class="sd">        CDELT : -0.27794934051515896  0.27794934051515896</span>
<span class="sd">        NAXIS : 0  0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span>
        <span class="c1"># The center is set to the barycenter of all its HEALPix cells</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">barycenter</span><span class="p">()</span>
        <span class="c1"># The fov is computed from the largest distance between the center and any cells of it</span>
        <span class="n">fov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">largest_distance_from_coo_to_vertices</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">WCS</span><span class="p">(</span>
            <span class="n">fig</span><span class="p">,</span>
            <span class="n">fov</span><span class="o">=</span><span class="n">fov</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">coordsys</span><span class="o">=</span><span class="n">coordsys</span><span class="p">,</span>
            <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
            <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">w</span></div>


<div class="viewcode-block" id="MOC.plot">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;MOC&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the MOC object using a mollweide projection.</span>

<span class="sd">        **Deprecated**: New `fill` and `border` methods produce more reliable results and allow you to specify additional</span>
<span class="sd">        matplotlib style parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title : str</span>
<span class="sd">            The title of the plot</span>
<span class="sd">        frame : `astropy.coordinates.BaseCoordinateFrame`, optional</span>
<span class="sd">            Describes the coordinate system the plot will be (ICRS, Galactic are the only coordinate systems supported).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This method is deprecated and is no longer tested.&quot;</span>
            <span class="s2">&quot;Please refer to `MOC.fill` and `MOC.border` methods&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">frame</span> <span class="o">=</span> <span class="n">ICRS</span><span class="p">()</span> <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">frame</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearSegmentedColormap</span>

        <span class="n">plot_order</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">plotted_moc</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">degrade_to_order</span><span class="p">(</span><span class="n">plot_order</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">&gt;</span> <span class="n">plot_order</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="p">)</span>

        <span class="n">num_pixels_map</span> <span class="o">=</span> <span class="mi">1024</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">num_pixels_map</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="n">lon_rad</span><span class="p">,</span> <span class="n">lat_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">HEALPix</span><span class="p">(</span><span class="n">nside</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plotted_moc</span><span class="o">.</span><span class="n">max_order</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;nested&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frame</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">BaseCoordinateFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only Galactic/ICRS coordinate systems are supported.&quot;</span>
                <span class="s2">&quot;Please set `coord` to either &#39;C&#39; or &#39;G&#39;.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">pix_map</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">lonlat_to_healpix</span><span class="p">(</span><span class="n">lon_rad</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span> <span class="n">lat_rad</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">**</span> <span class="p">(</span><span class="n">plotted_moc</span><span class="o">.</span><span class="n">max_order</span><span class="p">))</span>
        <span class="n">pix_id</span> <span class="o">=</span> <span class="n">plotted_moc</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># change the HEALPix cells if the frame of the MOC is not the same as the one associated with the plot method.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">Galactic</span><span class="p">):</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">boundaries_lonlat</span><span class="p">(</span><span class="n">pix_id</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">sky_crd</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;deg&quot;</span><span class="p">)</span>
            <span class="n">pix_id</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">lonlat_to_healpix</span><span class="p">(</span><span class="n">sky_crd</span><span class="o">.</span><span class="n">galactic</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">sky_crd</span><span class="o">.</span><span class="n">galactic</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

        <span class="n">m</span><span class="p">[</span><span class="n">pix_id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">pix_map</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;mollweide&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;150°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;120°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;90°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;60°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;30°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;0°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;330°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;300°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;270°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;240°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;210°&quot;</span><span class="p">,</span>
                <span class="s2">&quot;180°&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>

        <span class="n">color_map</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s2">&quot;w2r&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;#eeeeee&quot;</span><span class="p">,</span> <span class="s2">&quot;#aa0000&quot;</span><span class="p">])</span>
        <span class="n">color_map</span><span class="o">.</span><span class="n">set_under</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">color_map</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">color_map</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">labelcolor</span><span class="o">=</span><span class="s2">&quot;#000000&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#555555&quot;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MOC.load">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.load">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;fits&quot;</span><span class="p">):</span>  <span class="c1"># noqa: A002</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the Spatial MOC from a file.</span>

<span class="sd">        Format can be &#39;fits&#39;, &#39;ascii&#39;, or &#39;json&#39;, though the json format is not officially supported by the IVOA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str or pathlib.Path</span>
<span class="sd">            The path to the file to load the MOC from.</span>
<span class="sd">        format : str, optional</span>
<span class="sd">            The format from which the MOC is loaded.</span>
<span class="sd">            Possible formats are &quot;fits&quot;, &quot;ascii&quot; or &quot;json&quot;.</span>
<span class="sd">            By default, ``format`` is set to &quot;fits&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;fits&quot;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">spatial_moc_from_fits_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;ascii&quot;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">spatial_moc_from_ascii_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;json&quot;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">spatial_moc_from_json_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;fits&quot;</span><span class="p">,</span> <span class="s2">&quot;ascii&quot;</span><span class="p">,</span> <span class="s2">&quot;json&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;format should be one of </span><span class="si">{</span><span class="n">formats</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_fits_raw_bytes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">raw_bytes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load MOC from raw bytes of a FITS file.&quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">spatial_moc_from_fits_raw_bytes</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

<div class="viewcode-block" id="MOC.from_string">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.from_string">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;ascii&quot;</span><span class="p">):</span>  <span class="c1"># noqa: A002</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deserialize the Spatial MOC from the given string.</span>

<span class="sd">        Format can be &#39;ascii&#39; or &#39;json&#39;, though the json format is not officially supported by the IVOA.</span>

<span class="sd">        WARNING: the serialization must be strict, i.e. **must not** contain overlapping elements</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        format : str, optional</span>
<span class="sd">            The format in which the MOC will be serialized before being saved.</span>
<span class="sd">            Possible formats are &quot;ascii&quot; or &quot;json&quot;.</span>
<span class="sd">            By default, ``format`` is set to &quot;ascii&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;ascii&quot;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">spatial_moc_from_ascii_str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;json&quot;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">spatial_moc_from_json_str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">,</span> <span class="s2">&quot;json&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;format should be one of </span><span class="si">{</span><span class="n">formats</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">uniq_hpx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a `np.array` of the uniq HEALPIx indices of the cell in the MOC.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The output is not sorted, the order follow the order of HEALPix cells in</span>
<span class="sd">        the underlying sorted array of depth29 nested ranges, i.e. the natural order</span>
<span class="sd">        of the cells is the underlying z-order curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">to_uniq_hpx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_depth29_ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the list of order 29 HEALPix nested ranges this MOC contains.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">to_ranges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">)</span>

<div class="viewcode-block" id="MOC.to_rgba">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.to_rgba">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_size</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a matplotlib compatible RGBA preview of the given MOC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_size : the number of pixels along the y-axis</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : A (2 * y_size, y_size, 4) array of 0-255 int values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">y_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.display_preview">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.display_preview">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_preview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_size</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a preview of the MOC (calling internally the `to_rgba` method).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_size : the number of pixels along the y-axis, default value is 300</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mocpy</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span> <span class="n">y_size</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MOC.barycenter">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.barycenter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">barycenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Barycenter of the MOC.&quot;&quot;&quot;</span>
        <span class="n">lonlat</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">get_barycenter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">lonlat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lonlat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;rad&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MOC.largest_distance_from_coo_to_vertices">
<a class="viewcode-back" href="../../../stubs/mocpy.MOC.html#mocpy.MOC.largest_distance_from_coo_to_vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">largest_distance_from_coo_to_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the largest distance between the given coordinates and vertices of the MOC cells.&quot;&quot;&quot;</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">mocpy</span><span class="o">.</span><span class="n">get_largest_distance_from_coo_to_moc_vertices</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store_index</span><span class="p">,</span>
            <span class="n">coo</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span>
            <span class="n">coo</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">rad</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2025, Matthieu Baumann &lt;matthieu.baumann@astro.unistra.fr&gt; Thomas Boch &lt;thomas.boch@astro.unistra.fr&gt; Manon Marchand &lt;manon.marchand@astro.unistra.fr&gt; F.-X. Pineau &lt;francois-xavier.pineau@astro.unistra.fr&gt;.<br/>
    Last built 26 May 2025. <br/>
  </p>
</footer>
  </body>
</html>